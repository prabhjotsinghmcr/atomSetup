"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var date = require('date-and-time');
var ts = require("./typesystem");
var DateOnlyR = (function (_super) {
    __extends(DateOnlyR, _super);
    function DateOnlyR() {
        _super.apply(this, arguments);
    }
    DateOnlyR.prototype.check = function (i) {
        if (typeof i == "string") {
            if (!date.isValid(i, "YYYY-MM-DD")) {
                return new ts.Status(ts.Status.ERROR, 0, "date-only should match to yyyy-mm-dd pattern", this);
            }
            return ts.ok();
        }
        return new ts.Status(ts.Status.ERROR, 0, "date-only should be string matching to  yyyy-mm-dd pattern ", this);
    };
    DateOnlyR.prototype.requiredType = function () {
        return ts.STRING;
    };
    DateOnlyR.prototype.value = function () {
        return true;
    };
    DateOnlyR.prototype.facetName = function () {
        return "should be date-only";
    };
    return DateOnlyR;
}(ts.GenericTypeOf));
exports.DateOnlyR = DateOnlyR;
var TimeOnlyR = (function (_super) {
    __extends(TimeOnlyR, _super);
    function TimeOnlyR() {
        _super.apply(this, arguments);
    }
    TimeOnlyR.prototype.check = function (i) {
        if (typeof i == "string") {
            var c = i.indexOf(".");
            if (c != -1) {
                i = i.substring(0, c);
            }
            if (!i.match("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]") || !date.isValid("11 " + i.trim(), "YY HH:mm:ss")) {
                return new ts.Status(ts.Status.ERROR, 0, "time-only should match to hh:mm:ss[.ff...] pattern", this);
            }
            return ts.ok();
        }
        return new ts.Status(ts.Status.ERROR, 0, "time-only should be string matching to  hh:mm:ss[.ff...] pattern ", this);
    };
    TimeOnlyR.prototype.requiredType = function () {
        return ts.STRING;
    };
    TimeOnlyR.prototype.value = function () {
        return true;
    };
    TimeOnlyR.prototype.facetName = function () {
        return "should be time-only";
    };
    return TimeOnlyR;
}(ts.GenericTypeOf));
exports.TimeOnlyR = TimeOnlyR;
var DateTimeOnlyR = (function (_super) {
    __extends(DateTimeOnlyR, _super);
    function DateTimeOnlyR() {
        _super.apply(this, arguments);
    }
    DateTimeOnlyR.prototype.check = function (i) {
        if (typeof i == "string") {
            var c = i.indexOf(".");
            if (c != -1) {
                i = i.substring(0, c);
            }
            if (!i.match("^\\d{4}-\\d{2}-\\d{2}T" + "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]$")) {
                return new ts.Status(ts.Status.ERROR, 0, "datetime-only should match to yyyy-mm-ddThh:mm:ss[.ff...] pattern", this);
            }
            return ts.ok();
        }
        return new ts.Status(ts.Status.ERROR, 0, "datetime-only should be string matching to  yyyy-mm-ddThh:mm:ss[.ff...] pattern ", this);
    };
    DateTimeOnlyR.prototype.requiredType = function () {
        return ts.STRING;
    };
    DateTimeOnlyR.prototype.value = function () {
        return true;
    };
    DateTimeOnlyR.prototype.facetName = function () {
        return "should be datetime-only";
    };
    return DateTimeOnlyR;
}(ts.GenericTypeOf));
exports.DateTimeOnlyR = DateTimeOnlyR;
var r1 = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\,[ ]+\d{2}[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+\d{4}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
var r2 = /(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\,[ ]+\d{2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
var r3 = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\,[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+\d{1,2}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
var r0 = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{1,3})?((?:[\+\-]\d{2}:\d{2})|Z)$/;
var DateTimeR = (function (_super) {
    __extends(DateTimeR, _super);
    function DateTimeR() {
        _super.apply(this, arguments);
    }
    DateTimeR.prototype.check = function (i) {
        var c = ts.VALIDATED_TYPE;
        var rfc2616 = false;
        c.allCustomFacets().forEach(function (x) {
            if (x.facetName() == "format") {
                if (x.value() === "rfc2616") {
                    rfc2616 = true;
                }
            }
        });
        if (typeof i == "string") {
            if (!rfc2616) {
                if (!i.match(r0)) {
                    return new ts.Status(ts.Status.ERROR, 0, "valid rfc3339 formatted string is expected", this);
                }
                return ts.ok();
            }
            else {
                if (!(i.match(r1) || i.match(r2) || i.match(r3))) {
                    return new ts.Status(ts.Status.ERROR, 0, "valid rfc2616 formatted string is expected", this);
                }
            }
            return ts.ok();
        }
        return new ts.Status(ts.Status.ERROR, 0, "valid datetime formatted string is expected", this);
    };
    DateTimeR.prototype.requiredType = function () {
        return ts.STRING;
    };
    DateTimeR.prototype.value = function () {
        return true;
    };
    DateTimeR.prototype.facetName = function () {
        return "should be datetime-only";
    };
    return DateTimeR;
}(ts.GenericTypeOf));
exports.DateTimeR = DateTimeR;
//# sourceMappingURL=datetime.js.map